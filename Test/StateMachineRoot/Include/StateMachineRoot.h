/** @file
 **
 ** ILUStateMachine is a library implementing a generic state machine engine.
 ** Copyright (C) 2018 Ivo Luyckx
 **
 ** This program is free software; you can redistribute it and/or modify
 ** it under the terms of the GNU General Public License as published by
 ** the Free Software Foundation; either version 2 of the License, or
 ** (at your option) any later version.
 **
 ** This program is distributed in the hope that it will be useful,
 ** but WITHOUT ANY WARRANTY; without even the implied warranty of
 ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ** GNU General Public License for more details.
 **
 ** You should have received a copy of the GNU General Public License along
 ** with this program; if not, write to the Free Software Foundation, Inc.,
 ** 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 **
 **/
#ifndef __StateMachineRoot__H__
#define __StateMachineRoot__H__

#include "CStateMachine.h"

/**********************************************************************************
 **
 ** This is the actual state machine.
 **
 ** There are no templates with a lot of instantiations (generating too much code
 ** in the current implementation.
 **
 ** There are no event type assumptions in the state machine engine.
 ** All events that can be generated by the event machine can be handled
 ** by member functions in the state classes, again without templates and
 ** any kind of cast.
 ** The handler functions can be event type specific. Thus receiving the
 ** appropriate data for the event directly as a pointer to the correct
 ** class. No casts or conversion are required.
 **
 ** Since each state is 1 class which is constructed when it is entered and
 ** destructed when it is left, the constructor and destructor can be used
 ** for on-entry and on-exit functionality (if required).
 **
 ** The state classes only derive from a very simple base class (having only a 
 ** virtual destructor). They do not have to implement any mandatory virtual 
 ** functions, ...
 ** They only have to implement handlers for events they actually handle, not for
 ** events they are not interested in.
 **
 ** If a state needs one or more threads to take care of 'work' in the state, 
 ** it can start/stop it whenever it wants and how it wants. No framework requirements.
 ** It only has to ensure the thread is stopped (and exited) before it destructor
 ** is exiting.
 ** Another possibility is that a state change should not occur as long as the
 ** workers are running (work has to be finished before switching state). It
 ** would be quite easy to implement this in the handler functions.
 ** Help functions and classes can be implemented to ease this, but using them if
 ** they are not sufficient for some reason, is not required.
 **
 ** The state classes have to ensure that the constructor, destructor and handlers are 
 ** all not-blocking. Hence the threads.
 **
 ** Since each state is a class, each state is implemented in its own .h and .cpp files.
 ** Next to these files there can be another common data class (state machine data 
 ** shared by all states, that also survices state transitions) and another file
 ** to implement the 'CreateState' functions so they are not a part of the class files
 ** themselves. This optimises compilation time when a class definition changes since
 ** this definition is only used in the 'CreateState' implementation and not in other
 ** headers. This stronly limits include file change propagations.
 **
 ** Limitations with respect to ILUStateMachine: 
 ** - the on-entry functions can not jump to another state, an event has to be 
 **   generated for this;
 ** - the on-exit functions can not jumpt to another state.
 ** Strengths with respect to ILUStateMachine:
 ** - .. there is something I thought of, just can't remember it now
 ** - much easier and less error prone to implement a state machine
 **
 **********************************************************************************/
namespace StateMachineRoot {
   //this is the one and only direct acces to the state machine:
   //the function to create it
   //the state machine itself will take care of registering event handlers,
   //creating states, creating data ...
   ILULibStateMachine::SPStateMachine CreateStateMachine(const unsigned int uiValue);
};

#endif //__StateMachineRoot_H__

